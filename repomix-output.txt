
================
File: server/app/routers/tools.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import or_
from app import models, schemas, database
from app.auth import get_current_admin  # ‚úÖ Admin Authentication
from app.utils import bestsoup_scraper  # ‚úÖ Web Scraping Utility


router = APIRouter()

# ‚úÖ Get Database Session
def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

# üîç Public: Get Approved Tools
@router.get("/", response_model=dict)
def get_tools(
    db: Session = Depends(get_db),
    search: str = Query(None),
    category: str = Query(None),
    pricing: str = Query(None),
    sort_by: str = Query(None),
    page: int = Query(1),
    limit: int = Query(10),
):
    query = db.query(models.Tool).filter(models.Tool.approved == True)

    if search:
        query = query.filter(
            or_(
                models.Tool.name.ilike(f"%{search}%"),
                models.Tool.description.ilike(f"%{search}%"),
            )
        )

    if category:
        query = query.filter(models.Tool.categories == category)

    if pricing:
        query = query.filter(models.Tool.pricing == pricing)

    if sort_by == "name":
        query = query.order_by(models.Tool.name)
    elif sort_by == "date":
        query = query.order_by(models.Tool.created_at.desc())

    total = query.count()
    tools = query.offset((page - 1) * limit).limit(limit).all()
    tools_data = [schemas.ToolResponse.from_orm(tool) for tool in tools]

    return {
        "total": total,
        "page": page,
        "limit": limit,
        "total_pages": (total // limit) + (1 if total % limit > 0 else 0),
        "tools": tools_data
    }

# ‚ûï Public: Create a New Tool Submission
@router.post("/", response_model=schemas.ToolResponse)
def create_tool(tool: schemas.ToolCreate, db: Session = Depends(get_db)):
    try:
        print("üì• Tool submission received:", tool)
        # Scrape metadata + get screenshot
        metadata = bestsoup_scraper(tool.url)
        print("üîç Metadata fetched:", metadata)


        blog_title = f"Exploring {tool.name}: A {tool.pricing.capitalize()} {tool.categories} Tool"
        blog_content = (
            f"{tool.name} is a {tool.pricing} tool designed to solve the problem of {tool.problem_it_solves}. "
            f"It offers features like {tool.key_features}. "
            f"{'Requires an account to use.' if tool.requires_account else 'No account needed to use this tool.'}"
        )

        db_tool = models.Tool(
            name=tool.name,
            description=metadata.get("description") or tool.description,
            categories=tool.categories,
            url=tool.url,
            pricing=tool.pricing,
            problem_it_solves=tool.problem_it_solves,
            key_features=tool.key_features,
            requires_account=tool.requires_account,
            approved=False,
            blog_title=blog_title,
            blog_content=blog_content,
        )
        db.add(db_tool)
        db.commit()
        db.refresh(db_tool)
        print("‚úÖ Tool successfully added:", db_tool.id)
        return db_tool

    except Exception as e:
        import traceback
        print("‚ùå Error during tool submission:", e)
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal Server Error")

# ‚úÖ Admin-Only: Approve a Tool
@router.put("/{tool_id}/approve")
def approve_tool(
    tool_id: int, 
    db: Session = Depends(get_db), 
    admin: models.Admin = Depends(get_current_admin)  # üîê Admin Required
):
    tool = db.query(models.Tool).filter(models.Tool.id == tool_id).first()
    if not tool:
        raise HTTPException(status_code=404, detail="Tool not found")

    tool.approved = True
    db.commit()
    return {"message": "Tool approved successfully"}

# üîé Admin-Only: Get Pending Tools
@router.get("/pending", response_model=list[schemas.ToolResponse])
def get_pending_tools(
    db: Session = Depends(get_db), 
    admin: models.Admin = Depends(get_current_admin)  # üîê Admin Required
):
    return db.query(models.Tool).filter(models.Tool.approved == False).all()

# ‚ùå Admin-Only: Delete a Tool
@router.delete("/{tool_id}")
def delete_tool(
    tool_id: int, 
    db: Session = Depends(get_db), 
    admin: models.Admin = Depends(get_current_admin)  # üîê Admin Required
):
    tool = db.query(models.Tool).filter(models.Tool.id == tool_id).first()
    
    if not tool:
        raise HTTPException(status_code=404, detail="Tool not found")
    
    db.delete(tool)
    db.commit()
    return {"message": "Tool deleted successfully"}

# üõ† Public: Get a Single Tool by ID
@router.get("/{tool_id}", response_model=schemas.ToolResponse)
def get_tool(tool_id: int, db: Session = Depends(get_db)):
    tool = db.query(models.Tool).filter(models.Tool.id == tool_id).first()
    if not tool:
        raise HTTPException(status_code=404, detail="Tool not found")
    return tool

================
File: server/app/routers/admin_routes.py
================
from fastapi import APIRouter, Depends, HTTPException , Response, status
from datetime import timedelta
from sqlalchemy.orm import Session
from app import database, models, schemas, security
from fastapi.security import OAuth2PasswordRequestForm
from app.auth import get_current_admin

router = APIRouter()

def get_db():
    db = database.SessionLocal()
    try:
        yield db
    finally:
        db.close()

ACCESS_TOKEN_EXPIRE_MINUTES = 60  # 1 hour

@router.post("/admin-login")
def admin_login(
    response: Response,
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(database.get_db)
):
    admin = db.query(models.Admin).filter(models.Admin.username == form_data.username).first()

    if not admin or not security.verify_password(form_data.password, admin.hashed_password):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": admin.username},
        expires_delta=access_token_expires
    )

    response.set_cookie(
        key="access_token",
        value=f"Bearer {access_token}",
        httponly=True,
        secure=True,  # ‚úÖ Use True in production
        samesite="None",
        max_age=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

    return {"message": "Login successful"}

# ‚úÖ Protected Admin Registration Route
@router.post("/register", response_model=schemas.AdminResponse)
def register_admin(
    admin: schemas.AdminCreate,
    db: Session = Depends(get_db),
    current_admin: models.Admin = Depends(get_current_admin)  # üõ°Ô∏è Protects the route
):
    if not current_admin.is_superuser:
        raise HTTPException(status_code=403, detail="Only superusers can register new admins")

    existing_admin = db.query(models.Admin).filter(models.Admin.username == admin.username).first()
    if existing_admin:
        raise HTTPException(status_code=400, detail="Admin already exists")

    hashed_password = security.hash_password(admin.password)
    new_admin = models.Admin(username=admin.username, hashed_password=hashed_password, is_superuser=True)
    db.add(new_admin)
    db.commit()
    db.refresh(new_admin)
    return new_admin

@router.post("/logout")
def logout_admin(response: Response):
    response.delete_cookie("access_token")
    return {"message": "Logged out successfully"}

@router.get("/me")
def get_admin(admin: models.Admin = Depends(get_current_admin)):
    return {"username": admin.username}



================================================================
End of Codebase
================================================================
